{"pages":[],"posts":[{"title":"Axios的优雅使用技巧","text":"前言在vue中使用最多的就是Axios了， 和Ajax和fetch的对比 Ajax:之所以vue不再使用ajax了，是因为本身是针对MVC的变成设计的，不符合现在MVVM的浪潮，并且，Ajax是基于原生的XHR开发，XHR本身架构不清晰，若要单纯使用Ajax，还得引入整个jQuery fetch:对于400和500都会被认为是成功请求 Axios 什么是Axios一个基于promise的HTTP库，可以用在浏览器和node当中, 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持PromiseAPI 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF Axios封装 封装的原因： 如果直接把axios直接挂载到vue的原型上是不对的， 代码会非常混乱 且污染了原型 性能受到了影响 在页面上API管理也会非常困难 容易受到攻击（服务器地址写到main.js上会被劫持到） 封装的流程 创建service.js文件 获取token1234function getToken(){ let token =seesionStorage.getItem('token') || ''; return token;} 创建实例12345const service axios.create({ baseURL:'apply', timeout:5000}) 创建request拦截器1234567891011121314service.interceptors.request.use( config=&gt;{ if(!getToken()){ return; } config.headers['token]=getToken(); config.headers['ContentType']='application/json;charset=utf-8'; return config; }, error=&gt;{ Promise.reject(error) } ) 创建response响应拦截器1234567891011121314service.interceptors.response.use( response=&gt;{ let res = response.data; if(res.code==&quot;401&quot;){ }else if(res.code=='402'){ } return Promise.resolve(res); }, error=&gt;{ return Promise.reject(error); }) 接口层：创建common.js 在此文件中可以封装各种特殊请求的方法以供调用（例如PUT DELETE请求）import service form ‘./service’ export default function requestPost(url,data){ service.post(url.data);}export default function requestGet(url,data){ service.get(url.data);} API层：专门存放每个业务模块api接口的位置 123456789import requestPost from '../request.common.js'//细分解耦 高度封装 统一管理export function postRequest(){ return new Promise(resolve,reject)=&gt;{ requestPost(url,data).then(res=&gt;resolve(data)).catch(error=&gt;reject(error)) }}","link":"/2020/11/17/Axios%E7%9A%84%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"Vue源码解析之准备","text":"0. 前言这篇主要是笔者对于vue 2.6.0源码阅读开始之前做的一些准备，仅是自己的见解和感悟，存在诸多不足之处，仅供参考。 1. 带着问题去学习在开始阅读源码之前，首先要有目的性，比如了解vue的优势在哪，并且带着对其优势的实现方式或者初始化整个过程的疑问开始阅读，这时候，在阅读源码之前，就能确定切入点，否则，不太容易下手。 2. 思考vue的实现思路在决定阅读源码之前，我们就应该可以确定自己阅读源码的目的，比如学习vue项目的设计思路，或者使自己在开发过程中如果遇到问题能解决的更加得心应手，迅速找到问题的根源。 3. 动手实现vue的核心响应式功能，化繁为简，由简到精在阅读源码之前，首先自己要有思路如何实现vue的核心功能，比如实现vue的双向绑定的整个过程，先用一个自己认为的最优的方式写出实现代码，再逐步完善细节问题，这样有助于我们阅读源码时把作者的思路和自己的思路进行对比，体味成熟框架设计的优美之处，对比自己的实现方式，吸纳优秀的思路，印象更深。 而自己写的实现方式要从vue初始化的格式要求出发，这样做出来的自己vue调用起来就跟真的vue一样，且思路有了切入点。 4. 源码结构 compiler 编译用的 vue使用字符串作为模板 在编译文件夹中存放对模板字符串的解析算法，抽象语法树、优化等 core核心，vue构造函数，以及生命周期等部分 platforms平台 针对运行环境的设备有不同的实现 也是vue的入口 server服务端，主要是将vue用在服务端的处理代码 sfc单文件组件 shared公共工具","link":"/2020/11/14/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%BC%80%E7%AF%87/"},{"title":"TS语法","text":"学习ts语法的必要性ts语法是微软开发的，是js的超集，即包含js的所有语法，最终在浏览器上运行之前，会通过工具把ts语法编译成js语法运行（因为目前浏览器还不能识别ts语法）。随着ts语法在大型复杂项目越来越多的使用，ts适用于大型项目开发的优势越来越明显，随着98%由ts开发的Vue-next版本问世，ts成为前端开发的大趋势，学习ts语法成为前端开发者迫在眉睫的任务。本篇以在vue-next版本开发功能为例，讲解ts语法的精妙特性。 ts语法的特性 类型说明 类型声明： 静态类型检测： 泛型定义数组，泛型约束，多种类型： 函数类型（参数类型，返回值类型）： ts中的类ts的类和es6的类基本相同，ts会多几个方法： 权限修饰符，访问修饰符 123456789Class Person { //受保护的，亚智能在本类和子类中使用 protected name:string; //属性和方法都可以在任何地方访问 pubilc gender=&quot;女; //私有的，只能在内部访问 private _money:number=100;} 构造函数有继承的用法 (stu继承Student)Class stu extend Student {} 接口，定义规范和约束 12345678910interface Zhang { name:string; age:number;}let getZhang =(zhang:Zhang)=&gt;{ retunr `姓名:${zhang.name} 年龄:${zhang.age}`;}let zhang={name:&quot;zhangs&quot;,age:16};console.log(getZhang(zhang)); 装饰器 （@component） =&gt;主要用于扩展功能 装饰器1234567891011121314151617181920//函数，装饰器，扩展属性和方法function fun(target:any){ target.prototype.url='动态扩展属性', target.prototype.run=()=&gt;{ console.log(&quot;动态扩展一个run方法&quot;); }}@funclass Hello { constructor(){ } getData(){ }}let hello:any=new Hello();console.log(hello.url);hello.run(); 装饰器工厂 12345678910111213141516let fun1 = (msg:string)=&gt;{ return (target:any)=&gt;{ target.prototype.url=msg }}@fun1(&quot;我是装饰器工厂&quot;);class Stu { constructor (){ } getData(){ }}let stu:any=new Stu();console.log(syu.url); 计算属性：在vue找那个要使用ts.vue-property-decorator，使用装饰器来简化书写 12@componentexport default 属性装饰器（本身是个函数） 123456function decProperty(params:any){ return function (target:any,attr:any){ target[attr]=params; }} 例如vue-next中的@Prop装饰器，用于父向子组件传值： 1234567@Componentexport default class HelloWord extends Vue{ @Prop() private msg!:string;}HTML:&lt;Hello msg=&quot;我是传到子组件的数据&quot;&gt;&lt;/Hello&gt;","link":"/2020/11/16/TS%E8%AF%AD%E6%B3%95/"},{"title":"vue shared文件夹详解","text":"1. constants.js定义了一些常量 2. util.js 工具方法，在代码中随处可用 类型判断方法 toString方法（重点注意）：粗略的将引用类型转换成json,粗略的将基本类型值转换成字符串 重点关注方法 makeMap方法：生成一个带有缓存的函数，用于判断数据是否是缓存中的数据，代表判断字符串（标签名）是否为内置的HTML标签 cached :生成带有缓存的函数（看点：闭包的应用） hyhenamteRE polygillBind","link":"/2020/11/19/vue-shared%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AF%A6%E8%A7%A3/"},{"title":"vue-next","text":"Vue 3 vue3的改变 更小 更快 加强typeScript支持 API一致性（vue2.X的兼容性问题） 提高可维护能力 开放更多是底层功能 vue3优势之更快 虚拟DOM:抽象层，并不具体存在","link":"/2020/11/18/vue3%E6%9D%A5%E4%BA%86/"}],"tags":[{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Vue源码","slug":"Vue源码","link":"/tags/Vue%E6%BA%90%E7%A0%81/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"shared目录","slug":"shared目录","link":"/tags/shared%E7%9B%AE%E5%BD%95/"},{"name":"vue3.x","slug":"vue3-x","link":"/tags/vue3-x/"}],"categories":[]}